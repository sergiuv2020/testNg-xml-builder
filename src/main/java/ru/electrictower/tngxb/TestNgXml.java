package ru.electrictower.tngxb;

import br.eti.kinoshita.testlinkjavaapi.model.TestCase;
import org.apache.log4j.Logger;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import ru.electrictower.tngxb.properties.XmlBuildProp;
import ru.electrictower.tngxb.properties.SelectionLogic;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.File;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.List;

import static com.google.common.base.Preconditions.checkNotNull;
import static javax.xml.transform.OutputKeys.INDENT;

/**
 * @author Aliaksei Boole
 */
class TestNgXml
{
    private static final Logger LOG = Logger.getLogger(TestNgXml.class);

    private XmlBuildProp xmlBuildProp;
    private SelectionLogic selectionLogic;
    private Document doc;

    TestNgXml(XmlBuildProp xmlBuildProp, SelectionLogic selectionLogic)
    {
        checkNotNull(xmlBuildProp, "xmlBuildProp");
        checkNotNull(selectionLogic, "selectionLogic");
        this.selectionLogic = selectionLogic;
        this.xmlBuildProp = xmlBuildProp;
    }

    public void build(List<TestCase> testCases)
    {
        try
        {
            String xmlFileName = xmlBuildProp.getXmlFileName();
            int startTestsCount = testCases.size();
            LOG.info("Start building TestNg xml file[" + xmlFileName + "]");
            doc = makeDocument();
            Element suiteNode = makeSuiteNode();
            Element testNode = makeTestNode(suiteNode);
            Element classesNode = makeClassesNode(testNode);
            List<Class> classes = Reflection.getClasses(xmlBuildProp.getBasePackage());
            for (Class clazz : classes)
            {
                Element classNode = makeClassNode(clazz.getName());
                Element methodsNode = makeMethodsNode(classNode);
                boolean isIncludes = false;

                Method[] methods = clazz.getDeclaredMethods();
                for (Method method : methods)
                {
                    Iterator<TestCase> testCaseIterator = testCases.iterator();
                    while (testCaseIterator.hasNext())
                    {
                        if (selectionLogic.select(method, testCaseIterator.next()))
                        {
                            makeIncludeNode(methodsNode, method.getName());
                            testCaseIterator.remove();
                            isIncludes = true;
                        }
                    }
                }
                if (isIncludes)
                {
                    makeExcludeNode(methodsNode);
                    classesNode.appendChild(classNode);
                }
            }
            LOG.info("Xml build end.");
            if (testCases.size() == startTestsCount)
            {
                LOG.error("No tests found in code!");
                System.exit(-1);
            }
            LOG.info("Found " + (startTestsCount - testCases.size()) + " tests in code.");
            if (testCases.size() != 0)
            {
                LOG.info(testCases.size() + " are MISSING!");
                LOG.info("Missing tests:");
                for (TestCase testCase : testCases)
                {
                    LOG.info("        " + testCase.getFullExternalId());
                }
            }
        }
        catch (Exception e)
        {
            processError(e);
        }
    }

    public void save()
    {
        LOG.info("Start saved xml to file[" + xmlBuildProp.getXmlFileName() + "]");
        try
        {
            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();
            transformer.setOutputProperty(INDENT, "yes");
            DOMSource source = new DOMSource(doc);
            StreamResult result = new StreamResult(new File(xmlBuildProp.getXmlFileName()));
            transformer.transform(source, result);
            LOG.info("File saved.");
        }
        catch (Exception e)
        {
            processError(e);
        }
    }

    private Document makeDocument() throws ParserConfigurationException
    {
        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
        return docBuilder.newDocument();
    }

    private Element makeSuiteNode()
    {
        Element suite = doc.createElement("suite");
        Comment comment = doc.createComment("Generated by TestNgXml.(From Belarus with love.)");
        suite.setAttribute("name", xmlBuildProp.getSuiteName());
        suite.setAttribute("verbose", "1");
        suite.setAttribute("preserve-order", "true");
        doc.appendChild(suite);
        doc.insertBefore(comment, suite);
        return suite;
    }

    private Element makeTestNode(Element suiteNode)
    {
        Element test = doc.createElement("test");
        test.setAttribute("name", xmlBuildProp.getTestName());
        test.setAttribute("verbose", "1");
        test.setAttribute("parallel", "classes");
        test.setAttribute("thread-count", xmlBuildProp.getThreadCount());
        suiteNode.appendChild(test);
        return test;
    }

    private Element makeClassNode(String className)
    {
        Element classNode = doc.createElement("class");
        classNode.setAttribute("name", className);
        return classNode;
    }

    private Element makeClassesNode(Element testNode)
    {
        Element classes = doc.createElement("classes");
        testNode.appendChild(classes);
        return classes;
    }

    private Element makeMethodsNode(Element classNode)
    {
        Element methodsNode = doc.createElement("methods");
        classNode.appendChild(methodsNode);
        return methodsNode;
    }

    private void makeIncludeNode(Element methodsNode, String methodName)
    {
        Element includeNode = doc.createElement("include");
        includeNode.setAttribute("name", methodName);
        methodsNode.appendChild(includeNode);
    }

    private void makeExcludeNode(Element methodsNode)
    {
        Element excludeNode = doc.createElement("exclude");
        excludeNode.setAttribute("name", ".*");
        methodsNode.appendChild(excludeNode);
    }

    private void processError(Throwable e)
    {
        LOG.error(e.getMessage(), e);
        System.exit(-1);
    }

}
